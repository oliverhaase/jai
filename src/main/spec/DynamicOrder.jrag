
// The attributes of this aspect model the 'maximum' control flow within a method.
// Maximum means several things:
// - conditional statements have multiple successors, one per possible branch
// - for a try block, each corresponding catch clause as well as the 
		regular next instruction belong to its successors
// - try blocks are assumed to be executed until the end to model the maximum
		effect of the block; if an exception is thrown within the block, the 
		actual effect might in fact be smaller. In this sense, the maximum 
		effect happens when no exception is thrown or an exception is thrown 
		in the last statement of the try block.
// - likewise, method bodies outside try blocks are assumed to be executed until the 
		end to model the maximum effect of the method; if an exception is thrown 
		within the method, the actual effect might in fact be smaller. In this sense, 
		the maximum effect happens when no exception is thrown or an exception is thrown 
		in the last statement of the method body.		    


aspect DynamicOrder {
	
	syn Instruction Method.lookup(int position) {
		for ( Instruction instruction : getInstructions() ) 
			if ( instruction.getPosition() == position ) 
				return instruction;
		return null;
	}
	
	inh Instruction Instruction.localLookup(int position);	
	eq Method.getInstruction(int i).localLookup(int position) = lookup(position);
	
	syn Instruction GotoInstruction.target() = localLookup(getTargetPosition());	
	
	syn Set<Instruction> BranchInstruction.targets() {
		Set<Instruction> targets = new HashSet<Instruction>();
		for ( int targetPos : getTargetPositions() ) 
			targets.add(localLookup(targetPos)); 
		return targets;	
	}
	
	// successors 
	
	syn Set<Instruction> Instruction.succ();
	
	eq Instruction.succ() = Collections.singleton(next());
	eq GotoInstruction.succ() = Collections.singleton(target());

	eq BranchInstruction.succ() {
		Set<Instruction> result = new HashSet<Instruction>();
		result.add(next());
		result.addAll(targets());
		return result;
	}
		
	eq ReturnInstruction.succ() = Collections.singleton(method().exitPoint());		
	eq Athrow.succ() = Collections.singleton(method().exitPoint());
	eq ExitPoint.succ() = new HashSet<Instruction>();

	
	// predecessors 

	coll Set<Instruction> Instruction.pred() [new HashSet<Instruction>()] with add root Method;
  
  	Instruction contributes this
    	to Instruction.pred()
    	for each succ();
    	
}