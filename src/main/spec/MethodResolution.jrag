aspect MethodResolution {

    // syn nta AlienClass Program.alienClass() = new AlienClass();
    // syn nta AlienMethod AlienClass.alienMethod() = new AlienMethod();
    
    syn String FieldLoadInstruction.getType() = ((ReferenceType) getFieldType()).getType();
    
    syn Method EarlyBoundInvokeInstruction.getTargetMethod() {
            java.lang.reflect.Method method = null;
        try {
            method = resolveMethodDefinition(Class.forName(getLoadClass(), false, null),
                    getMethodName(), getArguments());
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        return method().clazz().program().getClass(method.getDeclaringClass().getCanonicalName())
                .lookup(getMethodName(), getArguments());
        }
    
     /**
     * For internal created Objects (RealObject) the dynamic type is known and can be used
     * to resolve the Method to invoke.
     * For arguments (PhantomObject) all possible implementations of the static type in the 
     * current ClassPath are used.
     * For GlobalObjects all possible implementations of the LoadClassType in the 
     * current ClassPath are used.
     */     
    syn Set<Method> LateBoundInvokeInstruction.getTargetMethods(ReferenceSlot objRef) {
        HashSet<Method> methods = new HashSet<Method>();

        for (Class<?> clazz : getSubTypes(objRef)) {
            java.lang.reflect.Method method = resolveMethodDefinition(clazz, getMethodName(),
                    getArguments());
            methods.add(method().clazz().program()
                    .getClass(method.getDeclaringClass().getCanonicalName())
                    .lookup(getMethodName(), getArguments()));

        }

        return methods;
    }
    
    private Set<Class<?>> LateBoundInvokeInstruction.getSubTypes(ReferenceSlot objRef) {
        Set<Class<?>> targetClasses = new HashSet<Class<?>>();
        
        try {
            for (ObjectNode targetObject : objRef) {
                if (targetObject instanceof RealObject)
                    targetClasses.add(Class.forName(((RealObject) targetObject).getType()));
                if (targetObject instanceof PhantomObject)
                    targetClasses.addAll(getImplementationsOf(((PhantomObject) targetObject)
                            .getType()));
                if (targetObject instanceof GlobalObject)
                    targetClasses.addAll(getImplementationsOf(getLoadClass()));
            }
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }

        return targetClasses;
    }
    
    private Set<Class<?>> LateBoundInvokeInstruction.getImplementationsOf(String type) {
        // get all Implementations of the Type in the current ClassPath
        Set<Class<?>> classes = new HashSet<Class<?>>();
        for (String subType : ClassPath.getInstance().getSubTypesOf(type)) {
            try {
                classes.add(Class.forName(subType));
                // classes.add(Class.forName(subType, false, null));
            } catch (ClassNotFoundException e) {
                // clazz not in current ClassPath TODO
                e.printStackTrace();
            }
        }
        return classes;
    }
    
    
    syn boolean Method.matches(String methodName, List<Type> arguments) {
        if (!methodName.equals(getMethodName())
                || arguments.getNumChild() != getArguments().getNumChild())
            return false;

        for (int i = 0; i < arguments.getNumChild(); i++)
            if (!arguments.getChild(i).equals(getArguments().getChild(i)))
                return false;

        return true;
    }
    
    syn Method ByteCodeClass.lookup(String methodName, List<Type> arguments) {
        for ( Method method : getMethods() )
            if ( method.matches(methodName, arguments))
                return method;
        return null;
    }
    
    /**
     * Search for the definition of {@code methodName} in this class and all SuperClasses.
     * If the method wasn't found an AssertionError is thrown.
     */ 
    syn java.lang.reflect.Method InvokeInstruction.resolveMethodDefinition(Class clazz, String methodName, List<Type> arguments) {
        int i = 0;
        Class[] argumentClasses = new Class[arguments.numChildren];
        try {
            for (Type type : arguments) {
                argumentClasses[i++] = Class.forName(type.getType(), false, null);
            }
            if (true)
                clazz.getMethod(methodName, argumentClasses).getDeclaringClass()
                        .getDeclaredMethod(methodName, argumentClasses);
            return clazz.getMethod(methodName, argumentClasses);
        } catch (Exception e) {
            throw new NoSuchMethodError(e.getMessage());
        }
    }
}