aspect MethodResolution {

    // syn nta AlienClass Program.alienClass() = new AlienClass();
    // syn nta AlienMethod AlienClass.alienMethod() = new AlienMethod();
    
    syn String FieldLoadInstruction.getType() = ((ReferenceType) getFieldType()).getType();
    
    syn Method EarlyBoundInvokeInstruction.getTargetMethod() {
        Class<?> targetClass = resolveMethodDefinition(ClassPath.getClass(getLoadClass()),
                getMethodName(), getArguments());
        return method().clazz().program().getClass(targetClass.getCanonicalName())
                .lookup(getMethodName(), getArguments());
    }

    syn Set<Method> LateBoundInvokeInstruction.getTargetMethods(ReferenceSlot objRef) {
        HashSet<Method> methods = new HashSet<Method>();

        for (Class<?> clazz : getSubTypes(objRef)) {
            Class targetClass = resolveMethodDefinition(clazz, getMethodName(), getArguments());
            methods.add(method().clazz().program().getClass(targetClass.getCanonicalName())
                    .lookup(getMethodName(), getArguments()));
        }

        return methods;
    }
        
     /**
     * For internal created Objects (RealObject) the dynamic type is known and can be used
     * to resolve the Method to invoke.
     * For arguments (PhantomObject) all possible implementations of the static type in the 
     * current ClassPath are used.
     * For GlobalObjects all possible implementations of the LoadClassType in the 
     * current ClassPath are used.
     */     
    private Set<Class<?>> LateBoundInvokeInstruction.getSubTypes(ReferenceSlot objRef) {
        Set<Class<?>> targetClasses = new HashSet<Class<?>>();

        for (ObjectNode targetObject : objRef) {
            if (targetObject instanceof RealObject)
                targetClasses.add(ClassPath.getClass(((RealObject) targetObject).getType()));
            if (targetObject instanceof PhantomObject)
                targetClasses
                        .addAll(getSubTypes(((PhantomObject) targetObject).getType()));
            if (targetObject instanceof GlobalObject)
                targetClasses.addAll(getSubTypes(getLoadClass()));
        }

        return targetClasses;
    }
    
    private Set<Class<?>> LateBoundInvokeInstruction.getSubTypes(String type) {
        // get all Implementations of the Type in the current ClassPath
        Set<Class<?>> classes = new HashSet<Class<?>>();
        int i = 0;
        for (String subType : ClassPath.getInstance().getSubTypesOf(type)) {
            Class subClass = ClassPath.getClassIfAvailable(subType);
            if (subClass != null) // is in current ClassPath
                classes.add(subClass);
        }
        
        System.err.println("All: " + ClassPath.getInstance().getSubTypesOf(type).size()
                + " found: " + classes.size());
        return classes;
    }
    
    /**
     * Search for the definition of {@code methodName} in this class and all SuperClasses.
     * If the method wasn't found an AssertionError is thrown.
     */ 
    syn java.lang.Class InvokeInstruction.resolveMethodDefinition(Class clazz, String methodName, List<Type> arguments) {
        int i, j = 0;
        if (this instanceof InvokeStatic)
            i = 0;
        else
            i = 1;
        Class[] argumentClasses = new Class[arguments.numChildren - i];
        while (i < arguments.numChildren) {
            argumentClasses[j++] = ClassPath.getClass(arguments.getChild(i++).getType());
        }
        try {
            if (methodName.equals("<init>")) {
                return clazz.getConstructor(argumentClasses).getDeclaringClass();
            }
            if (true)
                clazz.getMethod(methodName, argumentClasses).getDeclaringClass()
                        .getDeclaredMethod(methodName, argumentClasses);
            return clazz.getMethod(methodName, argumentClasses).getDeclaringClass();
        } catch (NoSuchMethodException e) {
            throw new NoSuchMethodError(e.getMessage());
        }
    }
    
        
    syn boolean Method.matches(String methodName, List<Type> arguments) {
        if (!methodName.equals(getMethodName())
                || arguments.getNumChild() != getArguments().getNumChild())
            return false;

        for (int i = 0; i < arguments.getNumChild(); i++)
            if (!arguments.getChild(i).equals(getArguments().getChild(i)))
                return false;

        return true;
    }
    
    syn Method ByteCodeClass.lookup(String methodName, List<Type> arguments) {
        for ( Method method : getMethods() )
            if ( method.matches(methodName, arguments))
                return method;
        return null;
    }
}