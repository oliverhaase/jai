aspect MethodResolution {

    // syn nta AlienClass Program.alienClass() = new AlienClass();
    // syn nta AlienMethod AlienClass.alienMethod() = new AlienMethod();
    
    syn String FieldLoadInstruction.getType() = ((ReferenceType) getFieldType()).getType();
    
    syn Method EarlyBoundInvokeInstruction.getTargetMethod() {
        Class<?> targetClass = resolveMethodDefinition(ClassPath.getClass(getLoadClass()),
                getMethodName(), getArguments());
        return method().clazz().program().getClass(targetClass.getName())
                .lookup(getMethodName(), getArguments(), true);
    }

    syn Set<Method> LateBoundInvokeInstruction.getTargetMethods(ReferenceSlot objRef) {
        HashSet<Method> methods = new HashSet<Method>();

        for (Class<?> clazz : getClassesDeclaringMethod(objRef)) {
            methods.add(method().clazz().program().getClass(clazz.getName())
                    .lookup(getMethodName(), getArguments(), false));
        }

        return methods;
    }
        
     /**
     * For internal created Objects (RealObject) the dynamic type is known and can be used
     * to resolve the Method to invoke.
     * For arguments (PhantomObject) all possible implementations of the static type in the 
     * current ClassPath are used.
     * For GlobalObjects all possible implementations of the LoadClassType in the 
     * current ClassPath are used.
     */     
    private Set<Class<?>> LateBoundInvokeInstruction.getClassesDeclaringMethod(ReferenceSlot objRef) {
        Set<Class<?>> targetClasses = new HashSet<Class<?>>();

        for (ObjectNode targetObject : objRef) {
            if (targetObject instanceof RealObject)
                targetClasses.add(ClassPath.getClass(((RealObject) targetObject).getType()));
            if (targetObject instanceof PhantomObject)
                targetClasses.addAll(getSubTypes(((PhantomObject) targetObject).getType()));
            if (targetObject instanceof GlobalObject)
                targetClasses.addAll(getSubTypes(getLoadClass()));
        }

        if (getMethodName().equals("<init>") || getMethodName().equals("<clinit>"))
            throw new AssertionError("ctor !!!!!!!!!!!");

        for (Iterator<Class<?>> classes = targetClasses.iterator(); classes.hasNext();) {
            if (!declaresMethod(classes.next()))
                classes.remove();
        }
        return targetClasses;
    }

    private boolean LateBoundInvokeInstruction.declaresMethod(Class targetClass) {
        for (java.lang.reflect.Method method : targetClass.getDeclaredMethods()) {
            if (method.getName().equals(getMethodName())
                    && Arrays.equals(method.getParameterTypes(), getArgumentClasses(getArguments())))
                return true;
        }

        return false;
    }
    
    private Set<Class<?>> LateBoundInvokeInstruction.getSubTypes(String type) {
        // get all Implementations of the Type in the current ClassPath
        Set<Class<?>> classes = new HashSet<Class<?>>();
        for (String subType : ClassPath.getInstance().getSubTypesOf(type)) {
            Class subClass = ClassPath.getClassIfAvailable(subType);
            if (subClass != null) // is in current ClassPath
                classes.add(subClass);
        }
        
        System.err.println("All: " + ClassPath.getInstance().getSubTypesOf(type).size()
                + " found: " + classes.size());
        return classes;
    }
    
    /**
     * Search for the definition of {@code methodName} in this class and all SuperClasses.
     * If the method wasn't found an AssertionError is thrown.
     */ 
    syn java.lang.Class InvokeInstruction.resolveMethodDefinition(Class clazz, String methodName, List<Type> arguments) {
        Class[] argumentClasses = getArgumentClasses(arguments);
        try {
            if (methodName.equals("<init>") || methodName.equals("<clinit>"))
                return clazz.getConstructor(argumentClasses).getDeclaringClass();
            else
                return clazz.getMethod(methodName, argumentClasses).getDeclaringClass();
        } catch (NoSuchMethodException e) {
            throw new NoSuchMethodError(e.getMessage());
        }
    }

    public Class[] InvokeInstruction.getArgumentClasses(List<Type> arguments) {
        Class[] argumentClasses = new Class[arguments.numChildren - 1];
        for (int i = 1; i < arguments.numChildren; i++)
            argumentClasses[i - 1] = ClassPath.getClass(arguments.getChild(i).getType());
        return argumentClasses;
    }
    
    public Class[] InvokeStatic.getArgumentClasses(List<Type> arguments) {
        Class[] argumentClasses = new Class[arguments.numChildren];
        for (int i = 0; i < arguments.numChildren; i++)
            argumentClasses[i] = ClassPath.getClass(arguments.getChild(i).getType());
        return argumentClasses;
    }
    
        
    syn boolean Method.matches(String methodName, List<Type> arguments, boolean checkThisRef) {
        if (!methodName.equals(getMethodName())
                || arguments.getNumChild() != getArguments().getNumChild())
            return false;
        
        for (int i = checkThisRef ? 0 : 1; i < arguments.getNumChild(); i++)
            if (!arguments.getChild(i).equals(getArguments().getChild(i)))
                return false;

        return true;
    }
    
    syn Method ByteCodeClass.lookup(String methodName, List<Type> arguments, boolean checkThisRef) {
        for ( Method method : getMethods() )
            if ( method.matches(methodName, arguments, checkThisRef))
                return method;
        return null;
    }
}