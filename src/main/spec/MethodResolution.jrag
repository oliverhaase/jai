aspect MethodResolution {

    // syn nta AlienClass Program.alienClass() = new AlienClass();
    // syn nta AlienMethod AlienClass.alienMethod() = new AlienMethod();
    
    syn String FieldLoadInstruction.getType() = ((ReferenceType) getFieldType()).getType();
    
    syn Method EarlyBoundInvokeInstruction.getTargetMethod() = 
        method().clazz().program().getClass(getLoadClass())
            .resolveMethodDefinition(getMethodName(), getArguments());
    
     /**
     * For internal created Objects (RealObject) the dynamic type is known and can be used
     * to resolve the Method to invoke.
     * For arguments (PhantomObject) all possible implementations of the static type in the 
     * current ClassPath are used.
     * For GlobalObjects all possible implementations of the LoadClassType in the 
     * current ClassPath are used.
     */     
    syn Set<Method> LateBoundInvokeInstruction.getTargetMethods(ReferenceSlot objRef) {
        Set<ByteCodeClass> targetClasses = new HashSet<ByteCodeClass>();

        for (ObjectNode targetObject : objRef) {
            if (targetObject instanceof RealObject)
                targetClasses.add(getTargetMethodsOfDynamicType(((RealObject) targetObject)
                        .getType()));
            if (targetObject instanceof PhantomObject)
                targetClasses.addAll(getTargetMethodsOfStaticType(((PhantomObject) targetObject)
                        .getType()));
            if (targetObject instanceof GlobalObject)
                targetClasses.addAll(getTargetMethodsOfStaticType(getLoadClass()));
        }

        HashSet<Method> methods = new HashSet<Method>();

        for (ByteCodeClass clazz : targetClasses) 
            methods.add(clazz.resolveMethodDefinition(getMethodName(), getArguments()));
        
        return methods;
    }
    
    private ByteCodeClass LateBoundInvokeInstruction.getTargetMethodsOfDynamicType(String type) {
        return method().clazz().program().getClass(type);
    }

    private Set<ByteCodeClass> LateBoundInvokeInstruction.getTargetMethodsOfStaticType(String type) {
        // class or method is final TODO all ctors are private <=> final
        ByteCodeClass clazz = method().clazz().program().getClass(type);
        if (clazz.getIsFinal() || clazz.isMethodFinal(getMethodName(), getArguments())) {
            return Collections.singleton(clazz);
        }

        // methods of Object ? -> all Subtypes are too much -> use
        // implementation of Object ??? (jea)

        // get all Implementations of the Static Type in the current ClassPath
        Set<ByteCodeClass> classes = new HashSet<ByteCodeClass>();
        for (String subType : ClassPath.getInstance().getSubTypsOf(clazz.getName())) {
            ByteCodeClass subClazz = method().clazz().program().getClass(subType);
            if (subClazz != null) { // clazz not in current ClassPath TODO
	            classes.add(subClazz);
        }
        return classes;
    }
    
    
    syn boolean Method.matches(String methodName, List<Type> arguments) {
        if (!methodName.equals(getMethodName())
                || arguments.getNumChild() != getArguments().getNumChild())
            return false;

        for (int i = 0; i < arguments.getNumChild(); i++)
            if (!arguments.getChild(i).equals(getArguments().getChild(i)))
                return false;

        return true;
    }
    
    syn Method ByteCodeClass.lookup(String methodName, List<Type> arguments) {
        for ( Method method : getMethods() )
            if ( method.matches(methodName, arguments))
                return method;
        return null;
    }
    
    /**
     * Search for the definition of {@code methodName} in this class and all SuperClasses.
     * If the method wasn't found an AssertionError is thrown.
     */ 
    syn Method ByteCodeClass.resolveMethodDefinition(String methodName, List<Type> arguments) {
        Method method = lookup(methodName, arguments);
        if (method != null)
            return method;

        if (getName().equals("java.lang.Object"))
            throw new AssertionError("Method resolution failed: " + methodName + " not found");

        return program().getClass(getSuperClass()).resolveMethodDefinition(methodName, arguments);
    }
    
    syn boolean ByteCodeClass.isMethodFinal(String methodName, List<Type> arguments) {
        Method method = lookup(methodName, arguments);
        if (method != null)
            return method.getIsFinal();

        if (getName().equals("java.lang.Object"))
            return false; // no method definition found (must be defined in interface, so must not be final)

        return program().getClass(getSuperClass()).isMethodFinal(methodName, arguments);
    }
}