
aspect FieldEdges {
	
	syn FieldEdges Method.createInitialFieldEdges() = FieldEdges.getInstance();
		
    syn FieldEdges Instruction.transferFieldEdges(FieldEdges fieldEdgesIn) = fieldEdgesIn;
	
    syn FieldEdges FieldAssignmentInstruction.transferFieldEdges(FieldEdges fieldEdgesIn, Slot value,
            ReferenceSlot objReference) {
        // notation: obj.field = value
        HashSet<FieldEdge> fieldEdges = new HashSet<FieldEdge>();

        if (value instanceof ReferenceSlot)
            for (ObjectNode obj : objReference.getObjects())
                for (ObjectNode referredValue : ((ReferenceSlot) value).getObjects())
                    fieldEdges.add(new FieldEdge(obj, getFieldName(), referredValue));

        return fieldEdgesIn.addAll(fieldEdges);
    }
	
	/*
	
	eq NewInstruction.statesOut() =
		States.processStates(statesIn(), new StateProcessor() {
			@Override public State process(State original) {
				Heap heap = original.getHeap();
				
				ObjectNode obj = new InternalObject(
					method().clazz().getName() + "." 
						+ method().getMethodName() + "|"
						+ method().getSignatureIndex() + ":"
						+ getPosition(), 
					getType(), 
					ClassHelper.isRunnable(getType()) ? EscapeState.GLOBAL_ESCAPE : EscapeState.NO_ESCAPE);
					
				ReferenceNode ref = new ReferenceNode(getPosition(), Category.LOCAL);
				heap = heap.addReferenceAndTarget(ref, obj); 
				return new State(
					original.getLocalVars(), 
					original.getOpStack().pop(getConsumeStack()).push(ref), 
					heap); 
			}
		});
	
	eq InvokeInstruction.statesOut() {
		Set<State> result = new HashSet<State>();

		for ( State frameIn : statesIn() ) 
			for ( Method targetMethod : resolveTargetMethod() ) 
				result.add(frameIn.applyMethodSummary(
					targetMethod.methodSummary(), 
					getConsumeStack(), 
					getProduceStack(), 
					getReturnType(),
					getPosition()));
					
		return result;
	}	
		

	*/
	
	
}