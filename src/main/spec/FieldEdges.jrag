
aspect FieldEdges {
	
	syn FieldEdges Method.createInitialFieldEdges() = FieldEdges.getInstance();
		
	syn FieldEdges Instruction.transferFieldEdges(FieldEdges fieldEdgesIn, OpStack opStack) = fieldEdgesIn;
	

	syn ReferenceSlot FieldAssignmentInstruction.getStoreObjectRef(OpStack opStack) = null;     
    syn ReferenceSlot PutField.getStoreObjectRef(OpStack opStack) =  (ReferenceSlot) opStack.pop().top();
    syn ReferenceSlot Aastore.getStoreObjectRef(OpStack opStack) =   (ReferenceSlot) opStack.pop().pop().top();
    syn ReferenceSlot PutStatic.getStoreObjectRef(OpStack opStack) = new ReferenceSlot(getGlobalObject());
                
    syn FieldEdges FieldAssignmentInstruction.transferFieldEdges(FieldEdges fieldEdgesIn, OpStack opStack) {
        // notation: obj.field = value
        Slot value = opStack.top();

        HashSet<FieldEdge> fieldEdges = new HashSet<FieldEdge>();

        if (value instanceof ReferenceSlot)
            for (ObjectNode obj : getStoreObjectRef(opStack).getObjects())
                for (ObjectNode referredValue : ((ReferenceSlot) value).getObjects())
                    fieldEdges.add(new FieldEdge(obj, getFieldName(), referredValue));

        return fieldEdgesIn.addAll(fieldEdges);
    }

    
    syn ReferenceSlot FieldLoadInstruction.getLoadObjectRef(OpStack opStack) = null;
    syn ReferenceSlot GetField.getLoadObjectRef(OpStack opStack) =  (ReferenceSlot) opStack.top();
    syn ReferenceSlot Aaload.getLoadObjectRef(OpStack opStack) =    (ReferenceSlot) opStack.pop().top();      
    syn ReferenceSlot GetStatic.getLoadObjectRef(OpStack opStack) = new ReferenceSlot(getGlobalObject());
    
    private Slot FieldLoadInstruction.getFieldValueSlot(OpStack opStack, FieldEdges fieldEdges) {
        Slot fieldValueSlot;
        if (getFieldType() instanceof org.apache.bcel.generic.ReferenceType) {
            Set<ObjectNode> fieldValues = new HashSet<ObjectNode>();

            // Null Handling?
            for (ObjectNode obj : getLoadObjectRef(opStack).getObjects())
                fieldValues.addAll(fieldEdges.getObjectsOfField(obj, getFieldName()));

            fieldValueSlot = ReferenceSlot.getInstance().addObjects(fieldValues);
        } else
            fieldValueSlot = PrimitiveSlot.getInstance();
        return fieldValueSlot;
    }

	
	/*
	
		
	eq AconstNull.statesOut() =
		States.processStates(statesIn(), new StateProcessor() {
			@Override public State process(State original) {
				Heap heap = original.getHeap();
				ReferenceNode ref = new ReferenceNode(getPosition(), Category.LOCAL);
				heap = heap.addReferenceAndTarget(ref, InternalObject.getNullObject()); 
				return new State(
					original.getLocalVars(), 
					original.getOpStack().pop(getConsumeStack()).push(ref), 
					heap); 
			}
		});
	
	syn ReferenceNode FieldAssignmentInstruction.getStoreObjectRef(State frame) = null;	
	syn ReferenceNode PutField.getStoreObjectRef(State frame) =
		(ReferenceNode) frame.getOpStack().get(frame.getOpStack().size() -2);
	syn ReferenceNode Aastore.getStoreObjectRef(State frame) =
		(ReferenceNode) frame.getOpStack().get(frame.getOpStack().size() -3);
	syn ReferenceNode PutStatic.getStoreObjectRef(State frame) = ReferenceNode.getGlobalRef();
				
	eq FieldAssignmentInstruction.statesOut() {
		// notation: obj.field = value
		return States.processStates(statesIn(), new StateProcessor() {
			@Override public State process(State original) {
				OpStack opStack = original.getOpStack();
				Heap heap = original.getHeap();
				
				// inspect type of value to be assigned
				Slot value = opStack.peek();
				
				if ( value instanceof ReferenceNode ) 
					for ( ObjectNode obj : heap.dereference(getStoreObjectRef(original)) ) 
						for ( ObjectNode referredValue : heap.dereference((ReferenceNode) value) ) 
							heap = heap.addField(obj, getFieldName(), referredValue);
				
				return new State(
					original.getLocalVars(), 
					opStack.pop(getConsumeStack()), 
					heap);
			}
		});	
	}
	
	
	syn ReferenceNode FieldLoadInstruction.getLoadObjectRef(State frame) = null;
	syn ReferenceNode GetField.getLoadObjectRef(State frame) =
		(ReferenceNode) frame.getOpStack().get(frame.getOpStack().size() -1);
	syn ReferenceNode Aaload.getLoadObjectRef(State frame) =
		(ReferenceNode) frame.getOpStack().get(frame.getOpStack().size() -2);		
	syn ReferenceNode GetStatic.getLoadObjectRef(State frame) = ReferenceNode.getGlobalRef();
	
	eq FieldLoadInstruction.statesOut() =
		// notation: load obj.field 
		States.processStates(statesIn(), new StateProcessor() {
			@Override public State process(State original) {
				OpStack opStack = original.getOpStack();
				Heap heap = original.getHeap();
				Slot result;
				
				if ( getFieldType() instanceof org.apache.bcel.generic.ReferenceType ) {
					result = new ReferenceNode(getPosition(), Category.LOCAL);
					Set<ObjectNode> allTargets = new HashSet<ObjectNode>();

					for ( ObjectNode obj :  heap.dereference(getLoadObjectRef(original))) {
						Set<ObjectNode> targets 
							= heap.getObjectNodes().getFieldOf(obj, heap.getFieldEdges(), getFieldName());
						if ( targets.isEmpty() ) {
							ObjectNode subObject = 
								PhantomObject.newSubPhantom(obj, getFieldName());
							heap = heap.addField(obj, getFieldName(), subObject);
							targets.add(subObject);
						}
						allTargets.addAll(targets);
					}
							
					heap = heap.addReferenceToTargets((ReferenceNode) result, allTargets);
					
				} else 
					result = DontCareSlot.values()[getProduceStack()];					
					
				return new State(
					original.getLocalVars(), 
					opStack.pop(getConsumeStack()).push(result, getProduceStack()), 
					heap);									
			}
		});	


			
	eq NewInstruction.statesOut() =
		States.processStates(statesIn(), new StateProcessor() {
			@Override public State process(State original) {
				Heap heap = original.getHeap();
				
				ObjectNode obj = new InternalObject(
					method().clazz().getName() + "." 
						+ method().getMethodName() + "|"
						+ method().getSignatureIndex() + ":"
						+ getPosition(), 
					getType(), 
					ClassHelper.isRunnable(getType()) ? EscapeState.GLOBAL_ESCAPE : EscapeState.NO_ESCAPE);
					
				ReferenceNode ref = new ReferenceNode(getPosition(), Category.LOCAL);
				heap = heap.addReferenceAndTarget(ref, obj); 
				return new State(
					original.getLocalVars(), 
					original.getOpStack().pop(getConsumeStack()).push(ref), 
					heap); 
			}
		});
	
	eq InvokeInstruction.statesOut() {
		Set<State> result = new HashSet<State>();

		for ( State frameIn : statesIn() ) 
			for ( Method targetMethod : resolveTargetMethod() ) 
				result.add(frameIn.applyMethodSummary(
					targetMethod.methodSummary(), 
					getConsumeStack(), 
					getProduceStack(), 
					getReturnType(),
					getPosition()));
					
		return result;
	}	
		

	*/
	
	
}