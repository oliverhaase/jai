
aspect FieldEdges {
	
	syn FieldEdges Method.createInitialFieldEdges() = FieldEdges.getInstance();
		
    syn FieldEdges Instruction.transferFieldEdges(FieldEdges fieldEdgesIn) = fieldEdgesIn;
	
  
	syn FieldEdges.FieldAssignmentInstruction.transferFieldEdges(FieldEdges fieldEdgesIn,
								ReferenceSlot objectRef, ReferenceSlot valueRef) {
		FieldEdges fieldEdgesOut = fieldEdgesIn;	
							
		for ( ObjectNode objectNode : objectRef ) 
			for ( ObjectNode valueNode : valueRef ) 
				fieldEdgesOut = 
					fieldEdges.out.add(new FieldEdge(objectNode, getFieldName(), valueNode));
		
		return fieldEdgesOut;
	}						

    syn FieldEdges FieldLoadInstruction.transferFieldEdges(FieldEdges fieldEdgesIn, Set<FieldEdge> newEdges) = 
    	 fieldEdgesIn.addAll(newEdges);
    	 

	
	/*
	
	eq NewInstruction.statesOut() =
		States.processStates(statesIn(), new StateProcessor() {
			@Override public State process(State original) {
				Heap heap = original.getHeap();
				
				ObjectNode obj = new InternalObject(
					method().clazz().getName() + "." 
						+ method().getMethodName() + "|"
						+ method().getSignatureIndex() + ":"
						+ getPosition(), 
					getType(), 
					ClassHelper.isRunnable(getType()) ? EscapeState.GLOBAL_ESCAPE : EscapeState.NO_ESCAPE);
					
				ReferenceNode ref = new ReferenceNode(getPosition(), Category.LOCAL);
				heap = heap.addReferenceAndTarget(ref, obj); 
				return new State(
					original.getLocalVars(), 
					original.getOpStack().pop(getConsumeStack()).push(ref), 
					heap); 
			}
		});
	
	eq InvokeInstruction.statesOut() {
		Set<State> result = new HashSet<State>();

		for ( State frameIn : statesIn() ) 
			for ( Method targetMethod : resolveTargetMethod() ) 
				result.add(frameIn.applyMethodSummary(
					targetMethod.methodSummary(), 
					getConsumeStack(), 
					getProduceStack(), 
					getReturnType(),
					getPosition()));
					
		return result;
	}	
		

	*/
	
	
}